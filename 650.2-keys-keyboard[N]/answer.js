/**
 * @param {number} n
 * @return {number}
 */
var minSteps = function(n) {
  let ans = 0, d = 2; // 2 是最小的素数因子，所以从 2 开始
  while (n > 1) {
    while (n % d === 0) { // 如果 d 仍然是当前 n 的最小素数因子，继续遍历
      ans += d;
      n /= d;
    }
    // 如果此时 d 不是当前 n 的最小素数因子了，那么 d++ 继续试探
    // 其实此处应该是把 d 变为比 d 大的下一个素数，但是我们没有必要在构建出一个素数因子的数组，因为得不偿失(还需要创建一个判断是否为素数的方法)，那会花费更多的时间和空间，不如让计算机一个个去试就好了
    d += 1;
  };
  return ans;
};

/*
 * 思路：素数分解
 * 将所有操作分成以copy为首的多组，例如操作CPPCPPPPCP可以分为[CPP][CPPPP][CP]三组
 * 假设每组的长度为g1,g2...完成第一组操作后，字符串有g1个A，完成第二组操作后字符串有g1 * g2个A。
 * 当完成所有操作时，共有g1 * g2 * ... * gn个A。
 * 我们最终想要N = g1 * g2 * ... * gn个A。如果gi是合数，存在gi = p * q，那么这组操作可以分解为两组，第一组包含1个C和p-1个P，第二组包含一个C和q-1个P。
 * 证明这种分割方式使用的操作最少。原本需要p * g步操作，分解后需要p + q步。因为p + q <= p * g，等价于1 <= (p-1)(q-1)，当p >= 2且q >= 2时上式永远成立。
 * 假设g1, g2, ... 就是N的素数分解，则需要的最少操作等于这些素数之和。
 * 时间复杂度：O(sqrt(N))，空间复杂度：O(1)
 * 
 * 输入数字 质数 = 1 x n
 *        非质数 = 约数 x m
 * 约数 质数 = 1 x n1
 *    非质数 = 约数1 x m1
 */
