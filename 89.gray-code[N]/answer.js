/**
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function(n) {
    let ret = [];
    for (let i = 0; i < 1<<n; i++) {
        ret.push(i ^ i>>1);
    }
    return ret;
};

/*
A:原码	G:格雷码 R:和上一格雷码异或得：（第0个算0）
0000=0	0000	0000=0
0001=1	0001	0001=1
0010=2	0011	0010=2
0011=3	0010	0001=1
0100=4	0110	0100=4
0101=5	0111	0001=1
0110=6	0101	0010=2
0111=7	0100	0001=1
1000=8	1100	1000=8
1001=9	1101	0001=1
1010=10	1111	0010=2
1011=11	1110	0001=1
1100=12	1010	0100=4
1101=13	1011	0001=1
1110=14	1001	0010=2
1111=15	1000	0001=1

发现原码数列A[]和相邻格雷码的异或数列R[]有：
A[i] % R[i] ==0  且 A[i] % (2*R[i]) !=0 
也就是R列的值是 A列所含质因数2的乘积。
那就是将A的原码的最低位1提取出来即可。
提取原码a的最低位1：
①想办法去掉高位的1（除了最低位的1都算高位）
如a= 01011000 ，a-1=01010111， a^(a-1) = 00001111 =b(设为)，
 就是将a与 (a-1) 异或，因为a-1的减法借位，最多到最低位1为止。
执行①后虽然去掉了高位1，但也将低位0都变为1了。
设①执行后所得为b，下面想办法去掉b中的非最高位1：
b= 00001111 ，b+1=00010000，(b+1)>>1=00001000，即为所求。
验证a=0的特殊情况也符合要求！（注意不能  (b>>1)+1，这样0不合题意）
那就是 R[i] == (A[i] ^ (A[i]-1) +1)>>1。
如果我当时注意 A[i] 、A[i]>>1 和 R[i]之间的关系，那就做出最优解法了。
但是根据定义，我很难先按这个思路去想。
*/
